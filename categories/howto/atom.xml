<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Howto | Uptonian Thoughts]]></title>
  <link href="http://tupton.github.com/categories/howto/atom.xml" rel="self"/>
  <link href="http://tupton.github.com/"/>
  <updated>2012-07-22T22:07:45-05:00</updated>
  <id>http://tupton.github.com/</id>
  <author>
    <name><![CDATA[Thomas Upton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Configuration]]></title>
    <link href="http://tupton.github.com/2012/02/configuration"/>
    <updated>2012-02-18T20:43:38-06:00</updated>
    <id>http://tupton.github.com/2012/02/configuration</id>
    <content type="html"><![CDATA[<p>Starting a fresh environment on a new system isn’t a very common or regular task, but when you do, it comes in handy to have a quick and easy way to do it. To help with this, I keep my <code>vim</code> <a href="https://github.com/tupton/vim-support">environment</a> and my <a href="https://github.com/tupton/dotfiles">environment dot files</a> in version control on Github.</p>

<p>I use <a href="https://github.com/tpope/vim-pathogen">Pathogen</a> to manage my <code>vim</code> plugins. I follow the examples in <a href="http://vimcasts.org/episodes/synchronizing-plugins-with-git-submodules-and-pathogen/">this great article on plugin management with Pathogen</a> to keep most of my plugins as <code>git</code> submodules. Installing my <code>vim</code> environment is just a matter of cloning the <code>git</code> repository and symlinking my <code>vimrc</code>.</p>

<p>I just spent some time cleaning up and organizing my dotfiles.  I wasn’t even using my old dotfiles repository on GitHub, but I quickly rectified that. I now keep my dotfiles in <code>~/.dotfiles</code> and symlink them to <code>~</code>. There is a helper script in my <a href="https://github.com/tupton/dotfiles">dotfiles repository</a> that sets up these symlinks.</p>

<p>Along with the usual <code>bashrc</code>, there are a few config files that aren’t as common. My <code>ackrc</code> defines a few convenient options and ignores directories with built artifacts in them. My (old) <code>pythonrc</code> defines a tab-completion function, although this might be outdated at this point. There’s a <code>tm_properties</code> config for <a href="http://blog.macromates.com/2011/textmate-2-0-alpha/">TextMate 2</a>.</p>

<p>Hopefully the fact that my configuration is out in the open will bring to light some useful features that I probably take for granted but you might not know about. So, go explore! Check out my <code>inputrc</code>, for example. I know that I discover new things almost every time I look at someone else’s <code>vimrc</code> or <code>bashrc</code>.</p>

<p>Do you have any configuration tips or tricks? Let me know.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Local Backups are Great]]></title>
    <link href="http://tupton.github.com/2011/12/local-backups-are-great"/>
    <updated>2011-12-23T21:48:47-06:00</updated>
    <id>http://tupton.github.com/2011/12/local-backups-are-great</id>
    <content type="html"><![CDATA[<p>I use <a href="http://www.shirt-pocket.com/SuperDuper/SuperDuperDescription.html">SuperDuper!</a> to make daily backups to my local hard drive. <a href="http://www.thomasupton.com/blog/2010/12/automated-backups-with-tarsnap/">Remote backup</a> is important, but it’s always nice to have an easily-accessible way to recover from a hard drive disaster, especially when you need to fix the situation <em>quickly</em>.</p>

<h2 id="your-backup-device">Your Backup Device</h2>

<p>Choosing the right hard drive to use for your local backup isn’t a difficult choice, but it is an important one.  Sometimes you can find great deals on good brands (Western Digital or Seagate, to name a couple brands that I have used and liked) on <a href="http://www.newegg.com/">Newegg</a>. The requirements for a hard drive really depend on how you want to use it.</p>

<p>If you want a hard drive dedicated to backup, any drive with a relatively quick speed (I would go with 7200 RPM or higher) and a size that’s at least a bit bigger than the drive you’re backing up will be a great option.</p>

<p>If you want to use a hard drive for other things – to store your media or back up another drive – you’ll obviously need something bigger. I have a 1 TB drive that I have split into two volumes. One volume is a bit bigger than my MacBook Pro’s hard drive (128 GB)  and I use it to hold my backups; the other takes up the rest of the space and is used to store all of my music, movies, and photos.</p>

<p>Solid state drives are another option, but I’ve found that the extra cost isn’t worth the speed benefits. I would absolutely recommend a solid state drive to use in your main computer on a daily basis – I have a 128 GB solid state drive in my MacBook Pro and it’s noticeably faster than the mechanical hard drives I’ve used in MacBooks past. However, when it comes to something like backups, where you’re mostly writing to it in a situation that isn’t time-sensitive (e.g. at night), I think mechanical drives are the best option because you can get much more storage space for much less money.</p>

<h2 id="software-that-helps-you">Software That Helps You</h2>

<p>I mentioned earlier that I use SuperDuper!, but there are many other backup applications out there. Some of them may fit your specific needs better. The key feature is to have an automated and <em>bootable</em> copy of your hard drive ready to go at a moment’s notice.</p>

<p>I admittedly have not given Time Machine a fair shot, but that’s because I don’t have a use case for its main draw. “Going back in time” to an earlier version of a file is not something I need to do on a regular basis. And now with Lion’s Versions feature, I don’t need a whole backup just to keep recent versions of my files around.</p>

<p>Another option is <a href="http://www.bombich.com/ccc_features.html">Carbon Copy Cloner</a>. It makes bootable backups and can be scheduled to back up on a daily basis. It’s free to try; donations are requested if you continue to use the product.</p>

<p>I love SuperDuper! because it’s so simple. The interface tells you in plain English what is going to happen. I set up my nightly backups one time a couple years ago and the only time I ever see the app again is when I am traveling without my hard drive. When a backup fails, the application stays open to tell you what went wrong. That rarely happens though: usually an incremental backup occurs at 3am that takes less than ten minutes to complete. When it’s done, my data is safe and sound in two places.</p>

<p>The successful backups are bootable, meaning that you can just choose the backup volume as the boot volume when you <a href="http://support.apple.com/kb/HT1310">hold Option after you turn your computer on</a> and restore from there. If you just want to restore certain files instead of everything, the drive is right there in Finder for you to navigate as usual.</p>

<h2 id="backup-is-not-a-daunting-task">Backup Is Not a Daunting Task</h2>

<p>Almost none of my “non-technical” friends (i.e. friends who do other things in their lives besides fiddle with computers) back up their computers. And yet I know that each one of those friends would be devastated if their hard drive crashed and they lost their music or photos. Local backups are the simplest way to avoid this, and it’s so simple to set up:</p>

<ul>
  <li>Buy a hard drive (7200 RPM and at least as big as the drive you want to back up) and <a href="http://www.iclarified.com/entry/index.php?enid=1075">format it using OS X’s built-in Disk Utility</a>.</li>
  <li>Set up a <a href="http://www.shirt-pocket.com/SuperDuper/SuperDuperDescription.html">backup application</a> to do daily backups of your entire disk.</li>
</ul>

<p>That’s it. Back up your data. It’s so simple and so useful.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automated Backups with Tarsnap]]></title>
    <link href="http://tupton.github.com/2010/12/automated-backups-with-tarsnap"/>
    <updated>2010-12-12T20:14:08-06:00</updated>
    <id>http://tupton.github.com/2010/12/automated-backups-with-tarsnap</id>
    <content type="html"><![CDATA[<p>I remember <a href="http://www.daemonology.net/blog/2006-09-13-encrypted-backup.html">reading</a> <a href="http://www.daemonology.net/blog/2008-11-10-tarsnap-public-beta.html">about</a> <a href="http://www.tarsnap.com/">Tarsnap</a> a couple of years ago, back when it was only an idea. I wasn’t too convinced about using a service that was in beta to back up my data, but I recently rediscovered that it had graduated to a full-blown product and signed up immediately.</p>

<p>Tarsnap is an encrypted backup tool based on archives. I’m not going to go into any details about the implementation, but you can read about the <a href="http://www.tarsnap.com/crypto.html">cryptography</a>, <a href="http://www.tarsnap.com/security.html">the security</a>, or anything else about the <a href="http://www.tarsnap.com/design.html">overall design</a> of the tool on the <a href="http://www.tarsnap.com/">Tarsnap site</a>. Basically, it creates archives (hence the “tar” part of the name), encrypts them, and stores them on <a href="http://aws.amazon.com/s3/">Amazon S3</a>. The “snap” part of the name refers to the idea that backups are done in “snapshots,” which means that backups are incremental and duplicate data can be shared between archives.</p>

<p>After you sign up for a Tarsnap account, put at least $5 (via Paypal) into your account, and <a href="http://www.tarsnap.com/man-tarsnap-keygen.1.html">generate a key</a>, you can begin backing up your data. You can read more about <a href="http://www.tarsnap.com/gettingstarted.html">getting started</a> and <a href="http://www.tarsnap.com/usage.html">using <code>tarsnap</code> in general</a>, but I really want to talk about automated backups with Tarsnap.</p>

<h2 id="a-simple-wrapper">A Simple Wrapper</h2>

<p>I found <a href="http://jonathanstreet.com/blog/setting-up-backups-with-tarsnap">a blog post by Jonathan Street</a> that detailed his automated backups, and that served as inspiration for my system. I wrote a little bash script to wrap <code>tarsnap</code> for my purposes:</p>

<p><code>bash
    #! /bin/bash
    echo `date +%F\ %T`: Beginning back up of $2
    /usr/local/bin/tarsnap -c -f $1-`date +%F` $2
    echo `date +%F\ %T`: Completed back up of $2
</code></p>

<p>Calling <code>tarsnap-backup.sh  </code> tells tarsnap to create an archive  of the specified directory with the given name and the current date. I was in business.</p>

<h3 id="generating-a-new-key">Generating a new key</h3>

<p>An aside: Jonathan Street’s blog post mentioned creating a new key that only had permission to read and write archives. I initially did the same thing, but for reasons I’ll get into later, I wanted the ability to delete backups, too. Generating a new key was extremely easy:</p>

<p><code>bash
    $ tarsnap-keymgmt --outkeyfile /root/tarsnap-rw.key -r -w /root/tarsnap.key
</code></p>

<p>This creates a new key in <code>/root/</code> called <code>tarsnap-rw.key</code> that only has read and write permission.</p>

<h2 id="automation">Automation</h2>

<h3 id="newsyslog"><code>newsyslog</code></h3>

<p>The simple wrapper script above was great, but if I was going to automate it, I needed those <code>echo</code> statements to go to a more permanent log file. If I was going to do daily backups of directories, I needed some sort of log management. After searching around a bit, it became clear that <code>newsyslog</code> was the way to go on OS X. Looking at the file in <code>/etc/newsyslog.conf</code> was enough to give me the basic file structure, but the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newsyslog&sektion;=8">man pages</a> go into a lot of detail.</p>

<p>I made a configuration called <code>user.conf</code> in <code>/etc/newsyslog.d/</code> and put my tarsnap logs inside. I decided to use a distinct log for each automated backup I do, as opposed to a single tarsnap log. I still haven’t decided if this is the right way to go, but I do like being able to quickly see the result of the last backup. My <code>user.conf</code> looks like the following.</p>

<pre><code>/var/log/tarsnap-backup-code.log                        640     5       1000    *       Z
/var/log/tarsnap-backup-documents.log                   640     5       1000    *       Z
</code></pre>

<p>This configuration tells <code>newsyslog</code> to gzip, roll to a new log once the current log exceeds 1MB in size, and keep at most five old logs.</p>

<h3 id="cron"><code>cron</code></h3>

<p>With log rotation in place, I could create a cron job.</p>

<pre><code>0 4 * * * /usr/local/bin/tarsnap-backup code ~/code &gt; /var/log/tarsnap-backup-code.log
</code></pre>

<p>This crontab schedules backups for my <code>code</code> directory at 4am daily and my <code>Documents</code> directory at 5am daily. I used <code>sudo crontabe -e</code> to create this because both <code>tarsnap</code> and my log file’s permissions require root privileges. This would have sufficed, but there was a nagging thought in the back of my head: I <a href="http://www.thomasupton.com/blog/2009/09/i-love-weather/">knew</a> that <code>launchd</code> is used in place of <code>cron</code> in OS X, and I thought this would give me a good opportunity to dive into even more options that <code>launchd</code> has to offer.</p>

<h3 id="launchd"><code>launchd</code></h3>

<p>Since I wanted these backups to run whenever possible, I decided to put my <code>launchd</code> backup configurations in <code>/Library/LaunchDameons</code> instead of <code>/Library/LaunchAgents</code>. LaunchDaemons are able to run without a logged-in user; this is exactly what I wanted. The <code>launchd</code> configuration for my <code>code</code> backup looks like the following:</p>

<p><code>html
    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN"
    "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
    &lt;plist version="1.0"&gt;
    &lt;dict&gt;
        &lt;key&gt;Label&lt;/key&gt;
        &lt;string&gt;com.thomasupton.backup-daily-code&lt;/string&gt;
        &lt;key&gt;ProgramArguments&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;/usr/local/bin/tarsnap-backup&lt;/string&gt;
            &lt;string&gt;code&lt;/string&gt;
            &lt;string&gt;/Users/thomas/code&lt;/string&gt;
        &lt;/array&gt;
        &lt;key&gt;GroupName&lt;/key&gt;
        &lt;string&gt;wheel&lt;/string&gt;
        &lt;key&gt;UserName&lt;/key&gt;
        &lt;string&gt;root&lt;/string&gt;
        &lt;key&gt;Nice&lt;/key&gt;
        &lt;integer&gt;1&lt;/integer&gt;
        &lt;key&gt;StandardErrorPath&lt;/key&gt;
        &lt;string&gt;/var/log/tarsnap-backup-code.log&lt;/string&gt;
        &lt;key&gt;StandardOutPath&lt;/key&gt;
        &lt;string&gt;/var/log/tarsnap-backup-code.log&lt;/string&gt;
        &lt;key&gt;StartCalendarInterval&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;Hour&lt;/key&gt;
            &lt;integer&gt;5&lt;/integer&gt;
            &lt;key&gt;Minute&lt;/key&gt;
            &lt;integer&gt;0&lt;/integer&gt;
        &lt;/dict&gt;
    &lt;/dict&gt;
    &lt;/plist&gt;
</code></p>

<p>The <code>ProgramArguments</code> section is exactly how I called the backup script from <code>cron</code>. The <code>UserName</code> and <code>GroupName</code> keys are important: they tell <code>launchd</code> to run the backup script as root, which, as I mentioned before, is necessary for using <code>tarsnap</code> and for appending to the log file. The <code>StandardErrorPath</code> and <code>StandardOutPath</code> keys tell <code>launchd</code> to redirect output to the proper log file. The <code>StartCalendarInterval</code> tells <code>launchd</code> to run this script at 5am daily.</p>

<p>After registering the configuration via <code>launchctl load /Library/LaunchDaemons/com.thomasupton.backup-daily-documents.plist</code>, my automated backup system was in place.</p>

<h2 id="backup-management">Backup Management</h2>

<p>Since Tarsnap backs up data with the notion of “snapshots” and keeps track of blocks of data (and not archive data), keeping multiple archives of the same data doesn’t make much sense. However, running a daily backup by creating a new archive would mean that many archives would build up fast. I decided that keeping at most three previous backups of the same data would suffice. I wanted to automate this, too. This is the reason I decided not to use a read-write-only key.</p>

<p>I added the following lines to my <code>tarsnap-backup.sh</code> script.</p>

<p><code>bash
    # Remove the backup from three days previous, if there is one
    echo `date +%F\ %T`: Removing backup of $2 from `date -v-3d +%F`
    /usr/local/bin/tarsnap -d -f $1-`date -v-3d +%F`
    echo `date +%F\ %T`: Completed removing backup of $2 from `date -v-3d +%F`
</code></p>

<p>The key to this is the date in the archive name passed to <code>tarsnap -d</code>. <code>date -v</code> lets you add a value to the date output, so <code>-v-3d</code> outputs the date from three days previous. Now, every scheduled backup attempts to delete the archive from three days ago in addition to creating a backup for the current day. Of course, if a backup is missed, this can lead to an accumulation of old archives. This is where the log files come in handy: I can just inspect the logs every couple of days to see what successfully ran and manually prune the archive list if necessary.</p>

<h3 id="large-backups">Large Backups</h3>

<p>I said “if a backup is missed,” but I didn’t mention why that might occur. The answer becomes apparent when you start talking about backing up large amounts of data. My <code>~/Documents</code> folder was over 12GB, and with my terrible upload speeds, that would mean that it would take a long, long time to upload everything. Even though I was able to prune the contents of <code>~/Documents</code> down to 6.5GB, I still needed more than an hour to back it up. <code>tarsnap</code> doesn’t perform more than one archive transaction at once, so if the <code>documents</code> archive was still running when the <code>code</code> archive process began, tarsnap would cancel the latter and continue with the former, hence a backup is missed. This is also another reason that I decided to keep separate log files for each backup job. The log lines for an in-progress job aren’t interspersed with a failed attempt to start another backup job.</p>

<p>The <code>documents</code> backup was still too large to have been done by the morning, and I didn’t really want to sacrifice my network connection just for the sake of a backup. Fortunately, <code>tarsnap</code> supports archive truncation. According to the <a href="http://www.tarsnap.com/man-tarsnap.1.html">man pages</a>, <code>tarsnap</code> responds to the <code>SIGQUIT</code> interrupt by truncating the archive and appending “<code>.part</code>” to the archive name. When my large backup job was still running, all I had to do was send the <code>SIGQUIT</code> signal with <code>kill -3</code> (alternatively, you could send <code>^Q</code> if you use <code>tarsnap</code> from a console and not from a scheduled job) and <code>tarsnap</code> would effectively “pause” the backup. The next time that same data is archived, <code>tarsnap</code> will recognize it and only upload new data. This works even with a different archive name, thanks to snapshots and block data.</p>

<h2 id="restoring-backups">Restoring Backups</h2>

<p>Tarsnap is a great service, but truly for those who know what they are doing. It took me far longer than I would like to admit to come up with a process for all of this, but it was worth it. Of course, creating backups is only one part of a complete system. The other, more important part, is restoration. Since <code>tarsnap</code> is built on <code>tar</code> and <code>libarchive</code>, this is incredibly simple. <code>tarsnap -x</code> extracts archives, and <code>tarsnap -r</code> writes a tar stream to <code>stdout</code>, which can be used to create a local tar.</p>

<p>If you like the idea of easy, encrypted backups, tarsnap is a great service. It’s cheap, secure, and reliable, plus it’s fun and easy to use if you’re comfortable with UNIX-style archiving tools.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pastebin From The Command-line]]></title>
    <link href="http://tupton.github.com/2010/12/pastebin-from-the-commandline"/>
    <updated>2010-12-11T14:42:56-06:00</updated>
    <id>http://tupton.github.com/2010/12/pastebin-from-the-commandline</id>
    <content type="html"><![CDATA[<p><a href="http://pastebin.com/">Pastebin.com</a> is a utility for sharing snippets of text with anyone. The service is simple: go to <a href="http://pastebin.com/">pastebin.com</a>, paste your text, click submit, and share the link. It’s useful for sharing time-saving snippets with you team, or for an impromptu, informal code review of changes that for one reason or another haven’t been committed yet (e.g. a design decision for which the author wants early feedback.)</p>

<blockquote>
  <p><em>10:56:55 AM</em> <strong>Mike Bulman</strong>: im gonna try to find one, but if it doesn’t exist im gonna write:  a service/app for osx that will post whatevers on the clipboard to pastebin and give you a url</p>
</blockquote>

<p>A couple of days ago, my friend <a href="http://twitter.com/#!/mikebulman">Mike</a> suggested that he wanted a utility that would make it easy to post to pastebin without having to break your workflow and go to the site. I thought “that sounds fun,” and went to work that evening.</p>

<p>Pastebin has a <a href="http://pastebin.com/api.php">simple RPC API</a> for posting content, and it’s perfect for <code>curl</code>. The very first version of the pastebin script was this simple <code>curl</code> script.</p>

<p><code>bash
    #! /usr/bin/env bash
    curl -s -X POST -d "paste_code=$1" "http://pastebin.com/api_public.php" | pbcopy
</code></p>

<p><code>paste_code</code> is the POST parameter that the pastebin API expects to contain pasted content, so we just POST that to the public API page. The output of a successful pastebin API call is the URL for the paste, so we pipe that to OS X’s clipboard for easy pasting. Right from the beginning, this is clearly an OS X-specific script, but I don’t think it would be that hard to interact with the Linux system clipboard via <code>xclip</code>.</p>

<p>Making this work for text from <code>stdin</code> instead of as an argument was easy, too.</p>

<p><code>bash
    #! /usr/bin/env bash
    to_paste=`cat /dev/stdin`
    curl -s -X POST -d "paste_code=$to_paste" "http://pastebin.com/api_public.php" | pbcopy
</code></p>

<p>Both Mike and I recently started using <a href="http://jumpcut.sourceforge.net/">Jumpcut</a>, a minimal clipboard manager for OS X, so I had the idea of copying the actual text that was posted to pastebin before copying the URL so both would be readily available via Jumpcut. I tried adding <code>echo "$to_paste" | pbcopy</code> before the <code>curl</code> call, but it didn’t always work. I didn’t actually find any documentation on it, but it seems that <code>pbcopy</code> does some sort of buffering so that too much text isn’t copied in quick succession. Adding a very hacky <code>sleep</code> call fixed it, so the resulting script became the following.</p>

<p><code>bash
#! /usr/bin/env bash
to_paste=`cat /dev/stdin`
echo "$to_paste" | pbcopy
sleep 1
curl -s -X POST -d "paste_code=$1" "http://pastebin.com/api_public.php" | pbcopy
</code></p>

<p>Having a commandline script is all well and good, but it’s on about the same usability level as using pastebin.com: instead of switching to a browser, you switch to a terminal, but you still have to paste content and get away from you original context. This is where OS X Services come into play.</p>

<p>The OS X Service menu is often neglected, but it’s very useful. There are some neat built-in services, like looking a word up in Dictionary or composing a new email with the selection. With tools like  <a href="http://www.macosxautomation.com/automator/">Automator</a> or <a href="http://wafflesoftware.net/thisservice/">ThisService</a>, creating your own service is easy. I created an Automator workflow that assumed the script was symbolically linked to <code>/usr/local/bin/pastebin</code> and called the script. You can easily add a keyboard shortcut to a Service in the System Preferences Keyboard Shortcuts preference pane.</p>

<p>I cleaned up the script by adding a few command line options using the <code>getopts</code> <code>bash</code> built-in. This was pretty useful and easy to use. I’m not a very proficient <code>bash</code> scripter, but I was easily able to add what I needed, including making the ability to copy the text optional and allowing a file to be used in place of <code>stdin</code>. <a href="http://ginatrapani.org/">Gina Trapani</a>’s excellent <a href="https://github.com/ginatrapani/todo.txt-cli">todo.txt</a> script was helpful in figuring out the correct syntax.</p>

<p><code>bash
    while getopts ":cf:h" Option
    do
        case $Option in
            c )
                PASTEBIN_COPY=1
                ;;
            f )
                PASTEBIN_FILE=$OPTARG
                ;;
            h )
                usage
                ;;
        esac
    done
</code></p>

<p>I wrapped the script and the Automator workflow and <a href="https://github.com/tupton/pastebin-cl/">added it to github</a>. You can <a href="https://github.com/tupton/pastebin-cl/blob/8ff3cdda9e0027c41416b285f2822781a0ba4b5e/pastebin.sh">view the original bash script</a> in its latest form if you’re interested.</p>

<p>All this was well and good, but a couple of things bothered me. I didn’t like that <code>sleep</code> call, and I knew that the pastebin API offered a few options that I wasn’t allowing users of this script to take advantage of. So I did what any normal developer would do: I rewrote the script in python. The <a href="https://github.com/tupton/pastebin-cl/blob/d462c57542e98f23c83dc6388e1e5ebbafe04c94/pastebin.py">original version of the script</a> was just a straight “port” of the <code>bash</code> script, but I had plans for more.</p>

<p>I have experience with <a href="https://github.com/tupton/python-yahoo-weather">simple python scripts</a>, but I decided I should try my luck using classes in order to wrap the pastebin API. It was really easy. The beginning of the class looked like the following.</p>

<p>``` python
    class Pastebin(object):
        “"”A wrapper for the pastebin API”””</p>

<pre><code>    pastebin_api = "http://pastebin.com/api_public.php"

    def __init__(self, paste_code, paste_name=None, paste_email=None, paste_subdomain=None,
            paste_private=False, paste_expire_date=PASTEBIN_EXPIRE_NEVER, paste_format=None):

        self.set_paste_code(paste_code)
        self.set_paste_name(paste_name)
        self.set_paste_email(paste_email)
        self.set_paste_subdomain(paste_subdomain)
        self.set_paste_private(paste_private)
        self.set_paste_expire_date(paste_expire_date)
        self.set_paste_format(paste_format) ```
</code></pre>

<p>Then all I had to do was use the class.</p>

<p><code>python
    pastebin = Pastebin(paste_code=lines, paste_name=opts.paste_name, paste_email=opts.paste_email,
                paste_subdomain=opts.paste_subdomain, paste_private=opts.paste_private,
                paste_expire_date=opts.paste_expire_date, paste_format=opts.paste_format)
    response = pastebin.paste()
    return response
</code></p>

<p>I have no idea if getters and setters are very “pythonic,” but they make sense to me, even if I’m only using them internally for this script. I used a pretty interesting trick to build the POST data string. I put the necessary data into a dictionary, but I needed to build a proper parameter string.</p>

<p><code>python
return "&amp;".join([k + "=" + str(v) for (k, v) in params.iteritems()])
</code></p>

<p>I love the syntax used for “inline” for-loops here. The extra <code>str()</code> call was used just in case a parameter (like expiration date) was accidentally interpreted as a number.</p>

<p>I updated the <a href="https://github.com/tupton/pastebin-cl/blob/master/README.md">README</a> to reflect the new options. Thankfully, only the symbolic link to <code>/usr/local/bin/pastebin</code> had to be updated in order to keep the workflow working. Using the pastebin script couldn’t be easier:</p>

<ol>
  <li><a href="https://github.com/tupton/pastebin-cl/archives/master">Download the script source</a>, extract it, and put it somewhere that makes sense, like <code>~/scripts</code>.</li>
  <li><code>ln -s ~/scripts/pastebin-cl/pastebin.py /usr/local/bin/pastebin</code></li>
  <li>Open the workflow in <code>automator/Paste to pastebin.com.workflow</code> and save it as a service, which should just be as easy as ⌘-S.</li>
  <li>Open System Preferences &gt; Keyboard, then Keyboard Shortcuts, then Services. Make sure that the “Paste to pastebin.com” service is checked. Optionally, you can give it a keyboard shortcut.</li>
  <li>Highlight some text in any OS X application and choose “Paste to pastebin.com” from the application menu’s “Services” submenu or use your keyboard shortcut. Now the pastebin URL is on you clipboard, ready to be pasted into a chat room or in a browser.</li>
</ol>

<p>Hopefully this script will be useful to developers all over. If you have any ideas about making this more portable (i.e. for use on Linux or Windows), let me know in the <a href="#respond">comments</a>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I Love Weather]]></title>
    <link href="http://tupton.github.com/2009/09/i-love-weather"/>
    <updated>2009-09-22T22:53:38-05:00</updated>
    <id>http://tupton.github.com/2009/09/i-love-weather</id>
    <content type="html"><![CDATA[<p><strong>UPDATE</strong>: It seems that Yahoo! has changed their weather URL formats, which breaks the script that fetches the weather image. In order to fix it, go to <a href="http://weather.yahoo.com/">Yahoo! Weather</a> and enter your desired location. Once you have the correct page loaded, replace the URL in the script with this new one. The script should start working again.</p>

<p>There’s no question that my post that describes my script to <a href="http://www.thomasupton.com/blog/2008/04/yahoo-weather-feeds-with-python/">get the current weather conditions with Python and Yahoo! weather feeds</a> is the most popular post on my site. It drives a huge proportion of the (small amount of) traffic that this site gets, and the post has many more comments than the average post.</p>

<p>Many <a href="http://www.flickr.com/photos/megatrond/3100049946/">people</a> <a href="http://www.flickr.com/photos/donnyboy09/3436467554/">post</a> images of their desktops in their best GeekTool getup, including ones that feature my weather script. <a href="http://www.flickr.com/photos/mgastongrillo/3858032308/">One of these in particular</a> had a lovely image to go along with his weather conditions. The author, <a href="http://www.flickr.com/photos/mgastongrillo/">Gato’s</a>, was kind enough to share how he <a href="http://www.flickr.com/photos/mgastongrillo/3858032308/#comment72157622208211629">retrieved and displayed this image</a> in the comments of the photo post. I love this idea, and tweaked Gato’s’ method. I thought I’d detail what I did in case anyone else is interested.</p>

<p><img src="http://farm3.static.flickr.com/2615/3951420535_9a3d34e105_o.png" alt="Partly Cloudy" /></p>

<p>Gato’s’ method of retrieving Yahoo!’s weather images involves <em>two</em> additional GeekTool entries: one to fetch the image, and one to display the image on the desktop. I knew that there was a better way to do this, and I knew it involved <a href="http://developer.apple.com/macosx/launchd.html"><code>launchd</code></a>. <code>launchd</code> is a system-wide service for starting and stopping daemons. It replaced <code>init</code>, <code>cron</code>, and many other utilities in OS X 10.4. You can find out a lot more on the previous link and on the <a href="http://en.wikipedia.org/wiki/Launchd">Wikipedia page</a>.</p>

<p>I had never used <code>launchd</code> before, but setting up my own entry was fairly straightforward after I read a couple of the related man pages. In particular, <a href="x-man-page://launchd.plist"><code>launchd.plist</code></a> and <a href="x-man-page://execvp"><code>execvp</code></a> were very useful. In order to get started, you need to use the Property List Editor, found in <code>/Developer/Applications/Utilities/Property List Editor.app</code>. If you do not have Apple’s developer tools installed, you can create an XML file with a <code>.plist</code> extension with the same contents.</p>

<p>Before we start creating a <code>launchd</code> item, we need the script for the item to run. I have provided a bash script version of Gato’s’ image-grabbing command. I added a fifteen second timeout argument to the initial <code>curl</code> call; this prevents long timeouts for those times that you are without a network connection. You will also need to replace the URL at the end of line three of the script with your weather forecast URL. Simply go to the <a href="http://weather.yahoo.com/">Yahoo! weather page</a> and put in your zip or location code in order to retrieve your weather page, then paste that page’s URL into the script. You can <a href="http://www.thomasupton.com/wp/wp-content/uploads/2009/09/get_weather_image.sh.zip">download the script here</a>.</p>

<p>``` bash
    #! /bin/bash</p>

<pre><code>/usr/bin/curl --connect-timeout 15 --silent "http://weather.yahoo.com/united-states/virginia/blacksburg-2365044/" |
/usr/bin/grep "forecast-icon" |
/usr/bin/sed "s/.*background\:url(\'\(.*\)\')\;\ _background.*/\1/" |
/usr/bin/xargs curl --silent -o /tmp/weather.png ```
</code></pre>

<p>Now we can create the property list that will launch our image-grabbing script. <code>launchd</code> works by parsing a particular format of property list file. The man page for <a href="x-man-page://launchd.plist"><code>launchd.plist</code></a> is very extensive and contains documentation on the entries that are allowed in a <code>launchd</code> item. If that is all a bit too dense, I will walk through the creation of a simple <code>launchd</code> item with the bare minimum of properties needed to launch our script.</p>

<p>Open Property List Editor.app and create a new item by clicking <strong>Add Item</strong> in the toolbar. In the <strong>Key</strong> column, type <code>Label</code>. The default <strong>Type</strong> is <em>string</em>, so type a label identifier in the <strong>Value</strong> column. I used <code>com.thomasupton.fetchweatherimage</code>. You can use whatever you like. Next, add another item and this time switch its <strong>Type</strong> to <em>boolean</em>. Type <code>KeepAlive</code> as the <strong>Key</strong> and don’t check the check box to leave its value as <code>false</code>. Add another <em>number</em> item called <code>StartInterval</code> and give it a value of <code>600</code>. Finally, add an <em>array</em> item called <code>ProgramArguments</code>. Add a child to this array (just click the <strong>Add Item</strong> button with the <code>Program Arguments</code> node selected) and give it a value of <code>/bin/bash</code>. Add a second child and give it a value of <code>/absolute/path/to/script/get_weather_image.sh</code>, with the <em>absolute</em> path to where you saved the script. I have pasted the XML contents of the file here, and you can <a href="http://www.thomasupton.com/wp/wp-content/uploads/2009/09/com.thomasupton.fetchweatherimage.plist">download the property list file here</a>. You can open the property list with a text editor to edit the contents if you do not have the Property List Editor installed.</p>

<p>``` xml
<?xml version="1.0" encoding="UTF-8"?>
&lt;!DOCTYPE plist PUBLIC “-//Apple//DTD PLIST 1.0//EN”
“http://www.apple.com/DTDs/PropertyList-1.0.dtd”&gt;
<plist version="1.0" /></p>
<dict>
    <key>Label</key>
    <string>com.thomasupton.fetchweatherimage</string>
    <key>KeepAlive</key>
    <false />
    <key>StartInterval</key>
    <integer>600</integer>
    <key>ProgramArguments</key>
    <array>
        <string>/bin/bash</string>
        <string>/Users/thomasupton/code/script/get_weather_image.sh</string>
    </array>
</dict>
<p>&lt;/plist&gt;
```</p>

<p>What we have just created is a <code>launchd</code> item that will only start on demand every 600 seconds and run our script to grab the weather image. Save the property list to <code>~/Library/LaunchAgents</code> and give it a name like <em>com.thomasupton.fetchweatherimage.plist</em>. Open Terminal.app and type the following command to load our new <code>launchd</code> item, replacing the name of the script with the file name that you saved your property list as.</p>

<pre><code>$ launchctl load ~/Library/LaunchAgents/com.thomasupton.fetchweatherimage.plist
</code></pre>

<p>Back in GeekTool, all you need to do is add one new entry. Make it a picture and give it the URL <code>file:///tmp/weather.png</code>. <em>Et voilà</em>, you have a beautiful image of your weather conditions on your desktop.</p>

<p>I <a href="http://www.flickr.com/photos/third/3946891446/">took a picture of my current desktop</a> to show you what it looks like. I gave the weather image an opacity of 60% for a more subtle effect.</p>

<p><img src="http://farm3.static.flickr.com/2498/3946891446_da67c218a9.jpg" alt="Snow Leopard Desktop" /></p>
]]></content>
  </entry>
  
</feed>
