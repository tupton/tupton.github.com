<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: howto | Uptonian Thoughts]]></title>
  <link href="http://blog.thomasupton.com/categories/howto/atom.xml" rel="self"/>
  <link href="http://blog.thomasupton.com/"/>
  <updated>2014-10-08T12:15:18-05:00</updated>
  <id>http://blog.thomasupton.com/</id>
  <author>
    <name><![CDATA[Thomas Upton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Migrating from Pathogen to Vundle]]></title>
    <link href="http://blog.thomasupton.com/2014/02/migrating-from-pathogen-to-vundle"/>
    <updated>2014-02-11T19:41:00-06:00</updated>
    <id>http://blog.thomasupton.com/2014/02/migrating-from-pathogen-to-vundle</id>
    <content type="html"><![CDATA[<p>For <a href="http://blog.thomasupton.com/2012/02/configuration/">a while now</a>, I’ve been using <a href="https://github.com/tpope/vim-pathogen">Pathogen</a> to manage my <code>vim</code> plugins as bundles. I thought I was making things easier for myself by <a href="http://vimcasts.org/episodes/synchronizing-plugins-with-git-submodules-and-pathogen/">using <code>git</code> submodules to help organize those plugins</a>, but submodules aren’t the best method for deploying a <code>vim</code> environment in multiple places.</p>

<p>Fortunately for me, other, smarter people did this same thing and decided to fix it. This <a href="http://jameslaicreative.com/moving-up-upgrading-from-pathogen-to-vundle/">blog post by James Lai</a> details moving from almost the exact same system as mine to <a href="https://github.com/gmarik/vundle">Vundle</a>, a newer and very <code>vim</code>-centric way of managing plugins. You list your plugins in your <code>vimrc</code>, you update them with <code>vim</code> (even though they are managed with <code>git</code>), and your <code>vim</code> environment is consistent everywhere.</p>

<p>I just migrated from Pathogen to Vundle, and I want to document the process.</p>

<p>First things first: clone Vundle into your <code>bundle/</code> directory.</p>

<p><code>bash
    ❯ git clone https://github.com/gmarik/Vundle.vim.git bundle/Vundle.vim
</code></p>

<p>The <a href="https://github.com/gmarik/Vundle.vim#quick-start">Vundle quick start guide</a> does a great job of getting you started, so if you’re just looking to use Vundle without any prior bundle management, I would start there. If you were managing your <code>vim</code> plugins with Pathogen and <code>git</code> submodules, the switch to Vundle is straightforward but requires a few more steps.</p>

<p>At the top of <a href="https://github.com/tupton/vim-support/blob/master/vimrc">my <code>vimrc</code></a> I added a new Vundle-specific section and added the code from the quick start guide.</p>

<p>&#8220;` vim
    “ Of course
    set nocompatible</p>

<pre><code>" Required Vundle setup
filetype off
set runtimepath+=~/.vim/bundle/vundle
call vundle#rc()

Bundle 'gmarik/vundle' ```
</code></pre>

<p>Next, I wanted to add all the bundles I already use. <code>git submodule foreach</code> can actually help here.</p>

<p>&#8220;` bash
    ❯ git submodule foreach git remote -v
    Entering ‘bundle/airline’
    origin  https://github.com/bling/vim-airline.git (fetch)
    origin  https://github.com/bling/vim-airline.git (push)
    Entering ‘bundle/characterize’
    origin  https://github.com/tpope/vim-characterize.git (fetch)
    origin  https://github.com/tpope/vim-characterize.git (push)</p>

<pre><code>[...] ```
</code></pre>

<p>I then just copied the GitHub user and repository name (the path portion of the remote URL minus “.git”) and passed that to Vundle’s <code>Bundle</code> command.</p>

<p>&#8220;` vim
    “ Better status line
    Bundle ‘bling/vim-airline’</p>

<pre><code>" ga for character descriptions
Bundle 'tpope/vim-characterize'

[...] ```
</code></pre>

<p>Now we need to remove the existing submodules. One of the big pains of using <code>git</code> submodules is removing them when you no longer need them. This made trying out plugins harder than it needed to be, and it makes the transition to Vundle a bit more complicated.</p>

<p>I reference <a href="http://stackoverflow.com/questions/1260748/how-do-i-remove-a-git-submodule">this Stack Overflow post about removing <code>git</code> submodules</a> every time I need to remove a plugin I was just trying out without fail. The command to remember is <code>git submodule deinit</code>. You can <code>deinit</code> all submodules in a given directory all at once.</p>

<p>&#8220;` bash
    ❯ git submodule deinit bundle/
    Cleared directory ‘bundle/airline’
    Submodule ‘bundle/airline’ (https://github.com/bling/vim-airline.git) unregistered for path ‘bundle/airline’
    Cleared directory ‘bundle/characterize’
    Submodule ‘bundle/characterize’ (https://github.com/tpope/vim-characterize.git) unregistered for path ‘bundle/characterize’</p>

<pre><code>[...] ```
</code></pre>

<p>Then you need to explicitly remove all the bundles. Since Vundle is already in <code>bundle/vundle</code>, we need to remove each separate plugin bundle directory instead of blowing away the entire <code>bundle/</code> directory.</p>

<p>&#8220;` bash
    ❯ git rm bundle/airline bundle/characterize […]
    rm ‘bundle/airline’
    rm ‘bundle/characterize’</p>

<pre><code>[...] ```
</code></pre>

<p>It woud be a good idea to commit your staged changes here, which at this point should just be submodule removal.</p>

<p>If you were using Pathogen, don’t forget to remove any setup from your <code>vimrc</code>.</p>

<p>&#8220;` vim
    “ Store pathogen itself in bundle/
    runtime! bundle/pathogen/autoload/pathogen.vim</p>

<pre><code>" Start it up
silent! call pathogen#infect()
silent! call pathogen#helptags() ```
</code></pre>

<p>It also helps to add <code>bundle/</code> to your <code>.gitignore</code>. Vundle now puts all plugins there, but you don’t have to manually manage them any more.. Just add <code>bundle/**</code> to your <code>vim</code> environment’s <code>.gitignore</code> file.</p>

<p>Now, open up <code>vim</code> and run <code>:BundleInstall</code>. All your <code>vim</code> bundles will be cloned and managed by Vundle, and you don’t have to worry about updating submodules and running <code>git submodule foreach</code> everywhere you have a <code>vim</code> environment.</p>

<p>To update and migrate any existing <code>vim</code> environments on other machines, <code>git pull</code> in the migration changes, which shouldn’t conflict as long as you were up to date to the commit before the migration. Then clone Vundle with <code>git clone https://github.com/gmarik/Vundle.vim.git bundle/vundle</code> and install your plugins with <code>vim +BundleInstall +qall</code>.</p>

<p>If you <em>were not</em> up to date to right before your migration changes, you’ll probably have to manually remove all submodules by following the instructions above and resolve some conflicts when pulling changes in. Since you’re trying to delete all of <code>bundle/</code>, this should be relatively painless: just delete <code>bundle/</code> and <code>git rebase --skip</code> any submodule update commits.</p>

<p>And now you’re using Vundle! Add some new bundles into your <code>vimrc</code>, run <code>:BundleInstall</code>, and you’re up and running. I found some that I’m going to try out in <a href="https://gist.github.com/joegoggins/8482408">joegoggins’s vimrc</a> and in <a href="https://github.com/gmarik/Vundle.vim#quick-start">the Vundle setup documentation</a>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Batch Deleting Last.fm Scrobbles]]></title>
    <link href="http://blog.thomasupton.com/2012/08/batch-deleting-last-fm-scrobbles"/>
    <updated>2012-08-12T20:06:00-05:00</updated>
    <id>http://blog.thomasupton.com/2012/08/batch-deleting-last-fm-scrobbles</id>
    <content type="html"><![CDATA[<p>I recently came home from a trip and synced my iPhone in iTunes in an attempt to scrobble the music
that I listened to on that trip. I use <a href="http://meloapp.com/faq/">Melo</a> to scrobble tracks played in iTunes, and it usually
works quite well because I never know it’s there.</p>

<p>I’m not entirely sure if Melo, iTunes, or <a href="http://last.fm/">Last.fm</a> is to blame, but I ended up with a large amount of
scrobbles from a repeated handful of songs. I have over 75,000 tracks scrobbled in Last.fm, but I
use their recommendations and like to look at my stats, so artificially inflating my scrobble
count with three artists was extremely undesirable.</p>

<p>I had 59 pages of unwanted scrobbles; I needed to quickly delete nearly 3000 scrobbles. Last.fm
doesn’t have a way to batch delete (or otherwise manage) your scrobble tracks, so I manually clicked
all the delete links on the first page.</p>

<p>That got old before I had even deleted ten scrobbles. I figured out a way to programmatically and
quickly delete a page of scrobbles. I still have to manually get to each page, but this makes it
much easier.</p>

<p><code>javascript
    jQuery('#deletablert a.delete').each(function(_, a) {
        a.click();
    });
</code></p>

<p>I just open up the console with <code>⌘-⌥-I</code>, paste in that snippet of code, and hit enter. Here is what
it looks like in action.</p>

<p><img src="http://farm9.staticflickr.com/8282/7770297078_73fafc7541_o_d.png" alt="Batch deleting Last.fm scrobbles." title="Last.fm Batch Delete" /></p>

<p>Since <a href="http://jquery.com/">jQuery</a> is already embedded in Last.fm’s pages, I just select all the delete links and
emit a click on each one. The entire page is deleted in a few seconds. When it’s done, I can click
the link to the previous page and repeat.</p>

<p>I don’t expect this will be very useful to anyone but myself for the next ten minutes, but it could
come in handy in case you’ve been listening to too much Carly Rae Jepsen.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Configuration]]></title>
    <link href="http://blog.thomasupton.com/2012/02/configuration"/>
    <updated>2012-02-18T20:43:38-06:00</updated>
    <id>http://blog.thomasupton.com/2012/02/configuration</id>
    <content type="html"><![CDATA[<p>Starting a fresh environment on a new system isn’t a very common or regular task, but when you do, it comes in handy to have a quick and easy way to do it. To help with this, I keep my <code>vim</code> <a href="https://github.com/tupton/vim-support">environment</a> and my <a href="https://github.com/tupton/dotfiles">environment dot files</a> in version control on Github.</p>

<p>I use <a href="https://github.com/tpope/vim-pathogen">Pathogen</a> to manage my <code>vim</code> plugins. I follow the examples in <a href="http://vimcasts.org/episodes/synchronizing-plugins-with-git-submodules-and-pathogen/">this great article on plugin management with Pathogen</a> to keep most of my plugins as <code>git</code> submodules. Installing my <code>vim</code> environment is just a matter of cloning the <code>git</code> repository and symlinking my <code>vimrc</code>.</p>

<p>I just spent some time cleaning up and organizing my dotfiles.  I wasn’t even using my old dotfiles repository on GitHub, but I quickly rectified that. I now keep my dotfiles in <code>~/.dotfiles</code> and symlink them to <code>~</code>. There is a helper script in my <a href="https://github.com/tupton/dotfiles">dotfiles repository</a> that sets up these symlinks.</p>

<p>Along with the usual <code>bashrc</code>, there are a few config files that aren’t as common. My <code>ackrc</code> defines a few convenient options and ignores directories with built artifacts in them. My (old) <code>pythonrc</code> defines a tab-completion function, although this might be outdated at this point. There’s a <code>tm_properties</code> config for <a href="http://blog.macromates.com/2011/textmate-2-0-alpha/">TextMate 2</a>.</p>

<p>Hopefully the fact that my configuration is out in the open will bring to light some useful features that I probably take for granted but you might not know about. So, go explore! Check out my <code>inputrc</code>, for example. I know that I discover new things almost every time I look at someone else’s <code>vimrc</code> or <code>bashrc</code>.</p>

<p>Do you have any configuration tips or tricks? Let me know.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Local Backups are Great]]></title>
    <link href="http://blog.thomasupton.com/2011/12/local-backups-are-great"/>
    <updated>2011-12-23T21:48:47-06:00</updated>
    <id>http://blog.thomasupton.com/2011/12/local-backups-are-great</id>
    <content type="html"><![CDATA[<p>I use <a href="http://www.shirt-pocket.com/SuperDuper/SuperDuperDescription.html">SuperDuper!</a> to make daily backups to my local hard drive. <a href="http://www.thomasupton.com/blog/2010/12/automated-backups-with-tarsnap/">Remote backup</a> is important, but it’s always nice to have an easily-accessible way to recover from a hard drive disaster, especially when you need to fix the situation <em>quickly</em>.</p>

<h2 id="your-backup-device">Your Backup Device</h2>

<p>Choosing the right hard drive to use for your local backup isn’t a difficult choice, but it is an important one.  Sometimes you can find great deals on good brands (Western Digital or Seagate, to name a couple brands that I have used and liked) on <a href="http://www.newegg.com/">Newegg</a>. The requirements for a hard drive really depend on how you want to use it.</p>

<p>If you want a hard drive dedicated to backup, any drive with a relatively quick speed (I would go with 7200 RPM or higher) and a size that’s at least a bit bigger than the drive you’re backing up will be a great option.</p>

<p>If you want to use a hard drive for other things – to store your media or back up another drive – you’ll obviously need something bigger. I have a 1 TB drive that I have split into two volumes. One volume is a bit bigger than my MacBook Pro’s hard drive (128 GB)  and I use it to hold my backups; the other takes up the rest of the space and is used to store all of my music, movies, and photos.</p>

<p>Solid state drives are another option, but I’ve found that the extra cost isn’t worth the speed benefits. I would absolutely recommend a solid state drive to use in your main computer on a daily basis – I have a 128 GB solid state drive in my MacBook Pro and it’s noticeably faster than the mechanical hard drives I’ve used in MacBooks past. However, when it comes to something like backups, where you’re mostly writing to it in a situation that isn’t time-sensitive (e.g. at night), I think mechanical drives are the best option because you can get much more storage space for much less money.</p>

<h2 id="software-that-helps-you">Software That Helps You</h2>

<p>I mentioned earlier that I use SuperDuper!, but there are many other backup applications out there. Some of them may fit your specific needs better. The key feature is to have an automated and <em>bootable</em> copy of your hard drive ready to go at a moment’s notice.</p>

<p>I admittedly have not given Time Machine a fair shot, but that’s because I don’t have a use case for its main draw. “Going back in time” to an earlier version of a file is not something I need to do on a regular basis. And now with Lion’s Versions feature, I don’t need a whole backup just to keep recent versions of my files around.</p>

<p>Another option is <a href="http://www.bombich.com/ccc_features.html">Carbon Copy Cloner</a>. It makes bootable backups and can be scheduled to back up on a daily basis. It’s free to try; donations are requested if you continue to use the product.</p>

<p>I love SuperDuper! because it’s so simple. The interface tells you in plain English what is going to happen. I set up my nightly backups one time a couple years ago and the only time I ever see the app again is when I am traveling without my hard drive. When a backup fails, the application stays open to tell you what went wrong. That rarely happens though: usually an incremental backup occurs at 3am that takes less than ten minutes to complete. When it’s done, my data is safe and sound in two places.</p>

<p>The successful backups are bootable, meaning that you can just choose the backup volume as the boot volume when you <a href="http://support.apple.com/kb/HT1310">hold Option after you turn your computer on</a> and restore from there. If you just want to restore certain files instead of everything, the drive is right there in Finder for you to navigate as usual.</p>

<h2 id="backup-is-not-a-daunting-task">Backup Is Not a Daunting Task</h2>

<p>Almost none of my “non-technical” friends (i.e. friends who do other things in their lives besides fiddle with computers) back up their computers. And yet I know that each one of those friends would be devastated if their hard drive crashed and they lost their music or photos. Local backups are the simplest way to avoid this, and it’s so simple to set up:</p>

<ul>
  <li>Buy a hard drive (7200 RPM and at least as big as the drive you want to back up) and <a href="http://www.iclarified.com/entry/index.php?enid=1075">format it using OS X’s built-in Disk Utility</a>.</li>
  <li>Set up a <a href="http://www.shirt-pocket.com/SuperDuper/SuperDuperDescription.html">backup application</a> to do daily backups of your entire disk.</li>
</ul>

<p>That’s it. Back up your data. It’s so simple and so useful.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automated Backups with Tarsnap]]></title>
    <link href="http://blog.thomasupton.com/2010/12/automated-backups-with-tarsnap"/>
    <updated>2010-12-12T20:14:08-06:00</updated>
    <id>http://blog.thomasupton.com/2010/12/automated-backups-with-tarsnap</id>
    <content type="html"><![CDATA[<p>I remember <a href="http://www.daemonology.net/blog/2006-09-13-encrypted-backup.html">reading</a> <a href="http://www.daemonology.net/blog/2008-11-10-tarsnap-public-beta.html">about</a> <a href="http://www.tarsnap.com/">Tarsnap</a> a couple of years ago, back when it was only an idea. I wasn’t too convinced about using a service that was in beta to back up my data, but I recently rediscovered that it had graduated to a full-blown product and signed up immediately.</p>

<p>Tarsnap is an encrypted backup tool based on archives. I’m not going to go into any details about the implementation, but you can read about the <a href="http://www.tarsnap.com/crypto.html">cryptography</a>, <a href="http://www.tarsnap.com/security.html">the security</a>, or anything else about the <a href="http://www.tarsnap.com/design.html">overall design</a> of the tool on the <a href="http://www.tarsnap.com/">Tarsnap site</a>. Basically, it creates archives (hence the “tar” part of the name), encrypts them, and stores them on <a href="http://aws.amazon.com/s3/">Amazon S3</a>. The “snap” part of the name refers to the idea that backups are done in “snapshots,” which means that backups are incremental and duplicate data can be shared between archives.</p>

<p>After you sign up for a Tarsnap account, put at least $5 (via Paypal) into your account, and <a href="http://www.tarsnap.com/man-tarsnap-keygen.1.html">generate a key</a>, you can begin backing up your data. You can read more about <a href="http://www.tarsnap.com/gettingstarted.html">getting started</a> and <a href="http://www.tarsnap.com/usage.html">using <code>tarsnap</code> in general</a>, but I really want to talk about automated backups with Tarsnap.</p>

<h2 id="a-simple-wrapper">A Simple Wrapper</h2>

<p>I found <a href="http://jonathanstreet.com/blog/setting-up-backups-with-tarsnap">a blog post by Jonathan Street</a> that detailed his automated backups, and that served as inspiration for my system. I wrote a little bash script to wrap <code>tarsnap</code> for my purposes:</p>

<p><code>bash
    #! /bin/bash
    echo `date +%F\ %T`: Beginning back up of $2
    /usr/local/bin/tarsnap -c -f $1-`date +%F` $2
    echo `date +%F\ %T`: Completed back up of $2
</code></p>

<p>Calling <code>tarsnap-backup.sh  </code> tells tarsnap to create an archive  of the specified directory with the given name and the current date. I was in business.</p>

<h3 id="generating-a-new-key">Generating a new key</h3>

<p>An aside: Jonathan Street’s blog post mentioned creating a new key that only had permission to read and write archives. I initially did the same thing, but for reasons I’ll get into later, I wanted the ability to delete backups, too. Generating a new key was extremely easy:</p>

<p><code>bash
    $ tarsnap-keymgmt --outkeyfile /root/tarsnap-rw.key -r -w /root/tarsnap.key
</code></p>

<p>This creates a new key in <code>/root/</code> called <code>tarsnap-rw.key</code> that only has read and write permission.</p>

<h2 id="automation">Automation</h2>

<h3 id="newsyslog"><code>newsyslog</code></h3>

<p>The simple wrapper script above was great, but if I was going to automate it, I needed those <code>echo</code> statements to go to a more permanent log file. If I was going to do daily backups of directories, I needed some sort of log management. After searching around a bit, it became clear that <code>newsyslog</code> was the way to go on OS X. Looking at the file in <code>/etc/newsyslog.conf</code> was enough to give me the basic file structure, but the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newsyslog&sektion;=8">man pages</a> go into a lot of detail.</p>

<p>I made a configuration called <code>user.conf</code> in <code>/etc/newsyslog.d/</code> and put my tarsnap logs inside. I decided to use a distinct log for each automated backup I do, as opposed to a single tarsnap log. I still haven’t decided if this is the right way to go, but I do like being able to quickly see the result of the last backup. My <code>user.conf</code> looks like the following.</p>

<pre><code>/var/log/tarsnap-backup-code.log                        640     5       1000    *       Z
/var/log/tarsnap-backup-documents.log                   640     5       1000    *       Z
</code></pre>

<p>This configuration tells <code>newsyslog</code> to gzip, roll to a new log once the current log exceeds 1MB in size, and keep at most five old logs.</p>

<h3 id="cron"><code>cron</code></h3>

<p>With log rotation in place, I could create a cron job.</p>

<pre><code>0 4 * * * /usr/local/bin/tarsnap-backup code ~/code &gt; /var/log/tarsnap-backup-code.log
</code></pre>

<p>This crontab schedules backups for my <code>code</code> directory at 4am daily and my <code>Documents</code> directory at 5am daily. I used <code>sudo crontabe -e</code> to create this because both <code>tarsnap</code> and my log file’s permissions require root privileges. This would have sufficed, but there was a nagging thought in the back of my head: I <a href="http://www.thomasupton.com/blog/2009/09/i-love-weather/">knew</a> that <code>launchd</code> is used in place of <code>cron</code> in OS X, and I thought this would give me a good opportunity to dive into even more options that <code>launchd</code> has to offer.</p>

<h3 id="launchd"><code>launchd</code></h3>

<p>Since I wanted these backups to run whenever possible, I decided to put my <code>launchd</code> backup configurations in <code>/Library/LaunchDameons</code> instead of <code>/Library/LaunchAgents</code>. LaunchDaemons are able to run without a logged-in user; this is exactly what I wanted. The <code>launchd</code> configuration for my <code>code</code> backup looks like the following:</p>

<p><code>html
    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN"
    "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
    &lt;plist version="1.0"&gt;
    &lt;dict&gt;
        &lt;key&gt;Label&lt;/key&gt;
        &lt;string&gt;com.thomasupton.backup-daily-code&lt;/string&gt;
        &lt;key&gt;ProgramArguments&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;/usr/local/bin/tarsnap-backup&lt;/string&gt;
            &lt;string&gt;code&lt;/string&gt;
            &lt;string&gt;/Users/thomas/code&lt;/string&gt;
        &lt;/array&gt;
        &lt;key&gt;GroupName&lt;/key&gt;
        &lt;string&gt;wheel&lt;/string&gt;
        &lt;key&gt;UserName&lt;/key&gt;
        &lt;string&gt;root&lt;/string&gt;
        &lt;key&gt;Nice&lt;/key&gt;
        &lt;integer&gt;1&lt;/integer&gt;
        &lt;key&gt;StandardErrorPath&lt;/key&gt;
        &lt;string&gt;/var/log/tarsnap-backup-code.log&lt;/string&gt;
        &lt;key&gt;StandardOutPath&lt;/key&gt;
        &lt;string&gt;/var/log/tarsnap-backup-code.log&lt;/string&gt;
        &lt;key&gt;StartCalendarInterval&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;Hour&lt;/key&gt;
            &lt;integer&gt;5&lt;/integer&gt;
            &lt;key&gt;Minute&lt;/key&gt;
            &lt;integer&gt;0&lt;/integer&gt;
        &lt;/dict&gt;
    &lt;/dict&gt;
    &lt;/plist&gt;
</code></p>

<p>The <code>ProgramArguments</code> section is exactly how I called the backup script from <code>cron</code>. The <code>UserName</code> and <code>GroupName</code> keys are important: they tell <code>launchd</code> to run the backup script as root, which, as I mentioned before, is necessary for using <code>tarsnap</code> and for appending to the log file. The <code>StandardErrorPath</code> and <code>StandardOutPath</code> keys tell <code>launchd</code> to redirect output to the proper log file. The <code>StartCalendarInterval</code> tells <code>launchd</code> to run this script at 5am daily.</p>

<p>After registering the configuration via <code>launchctl load /Library/LaunchDaemons/com.thomasupton.backup-daily-documents.plist</code>, my automated backup system was in place.</p>

<h2 id="backup-management">Backup Management</h2>

<p>Since Tarsnap backs up data with the notion of “snapshots” and keeps track of blocks of data (and not archive data), keeping multiple archives of the same data doesn’t make much sense. However, running a daily backup by creating a new archive would mean that many archives would build up fast. I decided that keeping at most three previous backups of the same data would suffice. I wanted to automate this, too. This is the reason I decided not to use a read-write-only key.</p>

<p>I added the following lines to my <code>tarsnap-backup.sh</code> script.</p>

<p><code>bash
    # Remove the backup from three days previous, if there is one
    echo `date +%F\ %T`: Removing backup of $2 from `date -v-3d +%F`
    /usr/local/bin/tarsnap -d -f $1-`date -v-3d +%F`
    echo `date +%F\ %T`: Completed removing backup of $2 from `date -v-3d +%F`
</code></p>

<p>The key to this is the date in the archive name passed to <code>tarsnap -d</code>. <code>date -v</code> lets you add a value to the date output, so <code>-v-3d</code> outputs the date from three days previous. Now, every scheduled backup attempts to delete the archive from three days ago in addition to creating a backup for the current day. Of course, if a backup is missed, this can lead to an accumulation of old archives. This is where the log files come in handy: I can just inspect the logs every couple of days to see what successfully ran and manually prune the archive list if necessary.</p>

<h3 id="large-backups">Large Backups</h3>

<p>I said “if a backup is missed,” but I didn’t mention why that might occur. The answer becomes apparent when you start talking about backing up large amounts of data. My <code>~/Documents</code> folder was over 12GB, and with my terrible upload speeds, that would mean that it would take a long, long time to upload everything. Even though I was able to prune the contents of <code>~/Documents</code> down to 6.5GB, I still needed more than an hour to back it up. <code>tarsnap</code> doesn’t perform more than one archive transaction at once, so if the <code>documents</code> archive was still running when the <code>code</code> archive process began, tarsnap would cancel the latter and continue with the former, hence a backup is missed. This is also another reason that I decided to keep separate log files for each backup job. The log lines for an in-progress job aren’t interspersed with a failed attempt to start another backup job.</p>

<p>The <code>documents</code> backup was still too large to have been done by the morning, and I didn’t really want to sacrifice my network connection just for the sake of a backup. Fortunately, <code>tarsnap</code> supports archive truncation. According to the <a href="http://www.tarsnap.com/man-tarsnap.1.html">man pages</a>, <code>tarsnap</code> responds to the <code>SIGQUIT</code> interrupt by truncating the archive and appending “<code>.part</code>” to the archive name. When my large backup job was still running, all I had to do was send the <code>SIGQUIT</code> signal with <code>kill -3</code> (alternatively, you could send <code>^Q</code> if you use <code>tarsnap</code> from a console and not from a scheduled job) and <code>tarsnap</code> would effectively “pause” the backup. The next time that same data is archived, <code>tarsnap</code> will recognize it and only upload new data. This works even with a different archive name, thanks to snapshots and block data.</p>

<h2 id="restoring-backups">Restoring Backups</h2>

<p>Tarsnap is a great service, but truly for those who know what they are doing. It took me far longer than I would like to admit to come up with a process for all of this, but it was worth it. Of course, creating backups is only one part of a complete system. The other, more important part, is restoration. Since <code>tarsnap</code> is built on <code>tar</code> and <code>libarchive</code>, this is incredibly simple. <code>tarsnap -x</code> extracts archives, and <code>tarsnap -r</code> writes a tar stream to <code>stdout</code>, which can be used to create a local tar.</p>

<p>If you like the idea of easy, encrypted backups, tarsnap is a great service. It’s cheap, secure, and reliable, plus it’s fun and easy to use if you’re comfortable with UNIX-style archiving tools.</p>
]]></content>
  </entry>
  
</feed>
